2017-03
===


[JVM为什么需要GC](http://www.infoq.com/cn/articles/why-jvm-need-gc)
--- 
2017-03-06, JVM, G1

GC发展简史

* JDK1.3.1 Serial GC - 串行方式
* JDK1.4.2 Parallel GC & Concurrent Mark Sweep (CMS) 
* JDK1.7   Garbage First GC

G1 - Garbage First 侧重点在于处理垃圾最多的地方，即垃圾优先


G1 GC的基本思想

* 并行性
* 并发性
* 分代GC
* 空间整理
* 可预见性


G1 GC垃圾回收机制

* 年轻代循环
* 多步骤并行标记循环
* 混合收集循环
* Full GC

G1 的区间设计灵感

在G1中，堆被分成若干个大小相等的区域（Region）。每个Region都有一个关联的Remembered Set ( 简称RS )，RS的数据结构是Hash表里面的数据是Card Table.   

![](../pictures/g1.png)

简单来说，RS里储存的是Region中存活对象的指针。当Region中的数据发生变化时，首先反映到Card Table 中的一个或多个Card上，RS通过扫描内部Card Table 得知Region中内存使用情况和存活对象。在使用Region过程中，如果Region被填满，分配内存的线程会重新选择一个新的Region，空闲的Region被组织到一个基于链表（LinkedList）的数据结构里，这样可以快速找到Region。  

![](../pictures/g1-2.png)



[HDFS NameNode 重启优化](http://www.infoq.com/cn/articles/namenode-restart-optimization)
--- 
2017-03-07, hdfs, namenode

基于[Hadoop-2.x](https://github.com/apache/hadoop/tree/branch-2) 和 [HA with QJM](http://hadoop.apache.org/docs/r2.7.1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html) 社区架构和系统设计：  
![](../pictures/qjm.png)

在HA with QJM架构下，NameNode的整个启动过程中始终以SBN（Standby NameNode）角色完成。

* NameNode 重启流程  
  * 加载FSImage
  * 回放EditLog
  * 执行Checkpoint
  * 收集所有DataNode的注册和数据块汇报

NameNode重启各阶段耗时占比：    
![](../pictures/namenode-restart-time.png)  







